

chamada wait(varCond*, mutex*)
-> A thread deve necessariamente adquirir um lock antes de chamá-la, pois a variável
que representa a condição deve ter exclusão mútua, pois ambas as threads a manipu
larão.
-> Quando executada, coloca a thread para dormir, liberando o lock.
-> Ao dormir, essa thread entrou em uma lista de espera para ser executada.
A fila está associada à variável de condição passada para a wait().

chamada signal(varCond*)
    -> Quando chamada, acorda uma thread que estava dormindo na fila daquela variável
de condição.
    -> Qual thread irá acordar depende da política de escalonamento do SO.
    -> A thread que acorda, readquire o mutex.
    -> O signal também precisa ser chamado em uma região de código que possui o lock,
pois ele sempre estará próximo à variável de condição, que é checada pela outra
thread. Dessa forma, evitamos problemas de concorrência.

pthread_exit() -> Sinaliza a finalização da thread.
pthread_joint() -> Bloqueia a execução do código até o fim da execução da thread.

A checagem do atendimento da condição tem que ser realizada por um while, não
um if. -> O while fornece uma redundância na thread que foi acordada, pois a
variável de condição será checada mais uma vez, na thread que foi acordada, pelo
teste do while, para garantir que o estado do programa é o realmente desejado.
Se, por algum motivo, não for, a o wait() será chamado novamente.

---
Da documentação:

" If the mutex type is PTHREAD_MUTEX_NORMAL, deadlock detection is not provided;
Attempting to relock the mutex causes deadlock. If a thread attempts to unlock
a mutex that it has not locked or a mutex which is unlocked, undefined behaviour
results.  "
---
